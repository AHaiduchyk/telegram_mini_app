<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Telegram QR Scanner</title>
  <style>
    :root {
      color-scheme: light dark;
      background: var(--tg-theme-bg-color, #f5f5f5);
      color: var(--tg-theme-text-color, #222);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    body { margin: 0; padding: 16px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    h2 { font-size: 16px; margin: 0 0 10px; }

    .card {
      background: var(--tg-theme-secondary-bg-color, #fff);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
    }

    .actions-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    button {
      background: var(--tg-theme-button-color, #2ea6ff);
      color: var(--tg-theme-button-text-color, #fff);
      border: none;
      padding: 10px 16px;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .btn-secondary {
      background: rgba(0,0,0,0.12);
      color: var(--tg-theme-text-color, #222);
    }
    .btn-success {
      background: #22c55e;
      color: #ffffff;
    }
    .btn-danger {
      background: #ef4444;
      color: #ffffff;
    }

    .btn-inline {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      line-height: 1;
    }

    .spinner {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.45);
      border-top-color: rgba(255,255,255,1);
      animation: spin 0.9s linear infinite;
      flex: 0 0 auto;
    }
    .btn-secondary .spinner {
      border-color: rgba(0,0,0,0.25);
      border-top-color: rgba(0,0,0,0.7);
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .toggle { display: flex; align-items: center; gap: 8px; margin-top: 8px; }

    .history-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
    }
    .history-item:last-child { border-bottom: none; }

    .history-left { flex: 1; min-width: 0; }
    .history-raw {
      font-size: 14px;
      word-break: break-word;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .history-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
      align-items: center;
    }

    .tag { font-size: 12px; color: var(--tg-theme-hint-color, #666); margin-top: 4px; }
    .muted { color: var(--tg-theme-hint-color, #666); font-size: 14px; }

    .details-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      margin-top: 10px;
    }
    .detail {
      background: rgba(0, 0, 0, 0.03);
      border-radius: 8px;
      padding: 8px;
      word-break: break-word;
    }

    .divider { height: 1px; background: rgba(0,0,0,0.08); margin: 12px 0; }

    .table {
      width: 100%;
      border-collapse: collapse;
      overflow: hidden;
      border-radius: 10px;
    }
    .table th, .table td {
      padding: 10px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      vertical-align: top;
      word-break: break-word;
      text-align: left;
      font-size: 14px;
    }
    .table th {
      background: rgba(0,0,0,0.03);
      font-weight: 600;
      width: 40%;
    }
    .section-title {
      font-size: 14px;
      font-weight: 700;
      margin: 10px 0 8px;
    }
  </style>
</head>
<body>
  <h1>QR Scanner</h1>

  <div id="not-telegram" class="card" style="display: none;">
    <strong>Open this Mini App inside Telegram.</strong>
    <p class="muted">The QR scanner relies on Telegram WebApp APIs.</p>
  </div>

  <div class="card">
    <div class="actions-row">
      <button id="scan-button">Scan QR</button>
    </div>

    <div class="toggle">
      <input type="checkbox" id="continuous" />
      <label for="continuous">Continuous scan</label>
    </div>

    <p class="muted" id="scan-status">Ready to scan.</p>
  </div>

  <div class="card">
    <h2>History</h2>
    <div id="history" class="muted">Loading...</div>
  </div>

  <div class="card" id="details-card">
    <h2>Details</h2>
    <div id="details" class="muted">Select a scan to view details.</div>
  </div>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;

    const notTelegramEl = document.getElementById("not-telegram");
    const scanButton = document.getElementById("scan-button");
    const scanStatus = document.getElementById("scan-status");
    const historyEl = document.getElementById("history");
    const detailsEl = document.getElementById("details");
    const detailsCardEl = document.getElementById("details-card");
    const continuousToggle = document.getElementById("continuous");

    const apiBase = new URLSearchParams(window.location.search).get("api") || window.location.origin;

    const state = {
      userId: null,
      scans: [],

      lastText: null,
      lastTextAt: 0,

      selectedScanKey: null,                 // raw_text
      checkCache: new Map(),                 // raw_text -> { text, parsed, check_id, saved, founded }
      findStatus: new Map(),                 // raw_text -> "idle" | "loading" | "founded" | "failed"
      saveStatus: new Map(),                 // raw_text -> "idle" | "loading" | "saved" | "failed"
    };

    function setStatus(message) {
      scanStatus.textContent = message;
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function getValidCheckUrl(rawText) {
      try {
        const url = new URL(rawText);
        if (url.hostname !== "cabinet.tax.gov.ua") return null;
        if (url.pathname !== "/cashregs/check") return null;
        const required = ["fn", "id", "sm", "time", "date"];
        const hasAll = required.every((key) => url.searchParams.get(key));
        return hasAll ? url.toString() : null;
      } catch {
        return null;
      }
    }

    function pickDbStatus(scan) {
      const st = scan?.info?.check_status;
      if (!st) return { founded: false, saved: false };
      return { founded: Boolean(st.founded), saved: Boolean(st.saved) };
    }

    function makeFindButtonUI(scanKey, canFind, dbFounded) {
      if (!canFind) return { className: "btn-secondary", disabled: true, html: "Find check" };

      const status = state.findStatus.get(scanKey) || (dbFounded ? "founded" : "idle");

      if (status === "loading") {
        return {
          className: "btn-secondary",
          disabled: true,
          html: `<span class="btn-inline"><span class="spinner" aria-hidden="true"></span><span>Finding</span></span>`
        };
      }
      if (status === "founded") {
        return { className: "btn-success", disabled: false, html: "Founded" };
      }
      if (status === "failed") {
        return { className: "btn-danger", disabled: false, html: "Retry" };
      }
      return { className: "btn-secondary", disabled: false, html: "Find check" };
    }

    function makeSaveButtonUI(scanKey, canSave, dbSaved) {
      const status = state.saveStatus.get(scanKey) || (dbSaved ? "saved" : "idle");

      if (status === "loading") {
        return {
          className: "btn-secondary",
          disabled: true,
          html: `<span class="btn-inline"><span class="spinner" aria-hidden="true"></span><span>Saving</span></span>`
        };
      }
      if (status === "saved") {
        return { className: "btn-success", disabled: true, html: "Saved" };
      }
      if (status === "failed") {
        return { className: "btn-danger", disabled: false, html: "Retry save" };
      }
      return { className: "btn-secondary", disabled: !canSave, html: "Save data" };
    }

    function upsertUniqueScan(scan) {
      const withoutDupes = state.scans.filter((s) => s.raw_text !== scan.raw_text);
      state.scans = [scan, ...withoutDupes];
    }

    function renderHistory() {
      if (!state.scans.length) {
        historyEl.textContent = "No scans yet.";
        return;
      }

      historyEl.innerHTML = "";
      state.scans.forEach((scan) => {
        const row = document.createElement("div");
        row.className = "history-item";

        const left = document.createElement("div");
        left.className = "history-left";
        left.innerHTML = `
          <div class="history-raw">${escapeHtml(scan.raw_text)}</div>
          <div class="tag">${escapeHtml(scan.type)}</div>
        `;

        const actions = document.createElement("div");
        actions.className = "history-actions";

        const scanKey = scan.raw_text;
        const canFind = Boolean(getValidCheckUrl(scan.raw_text));

        const { founded: dbFounded, saved: dbSaved } = pickDbStatus(scan);

        // ensure local maps align with DB
        if (dbFounded && (state.findStatus.get(scanKey) || "idle") === "idle") state.findStatus.set(scanKey, "founded");
        if (dbSaved && (state.saveStatus.get(scanKey) || "idle") === "idle") state.saveStatus.set(scanKey, "saved");

        const viewBtn = document.createElement("button");
        viewBtn.textContent = "View";
        viewBtn.addEventListener("click", () => showDetails(scan, { scroll: true }));

        const findBtn = document.createElement("button");
        const findUI = makeFindButtonUI(scanKey, canFind, dbFounded);
        findBtn.className = findUI.className;
        findBtn.disabled = findUI.disabled;
        findBtn.innerHTML = findUI.html;
        findBtn.addEventListener("click", async () => {
          if (!canFind) return;
          if ((state.findStatus.get(scanKey) || (dbFounded ? "founded" : "idle")) === "founded") {
            showDetails(scan, { scroll: true });
            return;
          }
          await findCheckForScan(scan);
          renderHistory();
          showDetails(scan, { scroll: true });
        });

        const saveBtn = document.createElement("button");
        const founded = (state.findStatus.get(scanKey) || (dbFounded ? "founded" : "idle")) === "founded";
        const cached = state.checkCache.get(scanKey);
        const hasXml = Boolean(cached && cached.text);
        const alreadySaved = (state.saveStatus.get(scanKey) || (dbSaved ? "saved" : "idle")) === "saved";
        const canSave = founded && hasXml && !alreadySaved;

        const saveUI = makeSaveButtonUI(scanKey, canSave, dbSaved);
        saveBtn.className = saveUI.className;
        saveBtn.disabled = saveUI.disabled;
        saveBtn.innerHTML = saveUI.html;
        saveBtn.addEventListener("click", async () => {
          const st = state.saveStatus.get(scanKey) || (dbSaved ? "saved" : "idle");
          if (st === "saved") return;
          await saveCheckForScan(scan);
          renderHistory();
          showDetails(scan, { scroll: true });
        });

        actions.appendChild(viewBtn);
        actions.appendChild(findBtn);
        actions.appendChild(saveBtn);

        row.appendChild(left);
        row.appendChild(actions);
        historyEl.appendChild(row);
      });
    }

    function renderKeyValueTable(obj) {
      const rows = Object.entries(obj || {})
        .filter(([, v]) => String(v ?? "").trim() !== "")
        .map(([k, v]) => `<tr><th>${escapeHtml(k)}</th><td>${escapeHtml(v)}</td></tr>`)
        .join("");
      if (!rows) return `<div class="muted">No data.</div>`;
      return `<table class="table">${rows}</table>`;
    }

    function renderRowsTable(rows, columns) {
      if (!rows || !rows.length) return `<div class="muted">No rows.</div>`;
      const thead = `<tr>${columns.map((c) => `<th>${escapeHtml(c)}</th>`).join("")}</tr>`;
      const tbody = rows
        .map((r) => `<tr>${columns.map((c) => `<td>${escapeHtml(r?.[c] ?? "")}</td>`).join("")}</tr>`)
        .join("");
      return `<table class="table"><thead>${thead}</thead><tbody>${tbody}</tbody></table>`;
    }

    function parseXmlToSummary(xmlText) {
      try {
        const doc = new DOMParser().parseFromString(xmlText, "text/xml");
        const parserError = doc.querySelector("parsererror");
        if (parserError) return null;

        const getText = (sel) => {
          const el = doc.querySelector(sel);
          return el ? (el.textContent || "").trim() : "";
        };

        const head = {
          ORGNM: getText("CHECKHEAD > ORGNM"),
          TIN: getText("CHECKHEAD > TIN"),
          POINTNM: getText("CHECKHEAD > POINTNM"),
          POINTADDR: getText("CHECKHEAD > POINTADDR"),
          ORDERDATE: getText("CHECKHEAD > ORDERDATE"),
          ORDERTIME: getText("CHECKHEAD > ORDERTIME"),
          CASHREGISTERNUM: getText("CHECKHEAD > CASHREGISTERNUM"),
          ORDERNUM: getText("CHECKHEAD > ORDERNUM"),
        };

        const total = { SUM: getText("CHECKTOTAL > SUM") };

        const bodyRows = [...doc.querySelectorAll("CHECKBODY > ROW")].map((row) => ({
          CODE: (row.querySelector("CODE")?.textContent || "").trim(),
          NAME: (row.querySelector("NAME")?.textContent || "").trim(),
          AMOUNT: (row.querySelector("AMOUNT")?.textContent || "").trim(),
          UNITNM: (row.querySelector("UNITNM")?.textContent || "").trim(),
          PRICE: (row.querySelector("PRICE")?.textContent || "").trim(),
          COST: (row.querySelector("COST")?.textContent || "").trim(),
          LETTERS: (row.querySelector("LETTERS")?.textContent || "").trim(),
        }));

        const payRows = [...doc.querySelectorAll("CHECKPAY > ROW")].map((row) => ({
          PAYFORMNM: (row.querySelector("PAYFORMNM")?.textContent || "").trim(),
          SUM: (row.querySelector("SUM")?.textContent || "").trim(),
        }));

        return { head, total, bodyRows, payRows };
      } catch {
        return null;
      }
    }

    function renderParsedReceipt(parsed, xmlText) {
      // prefer backend parsed shape: { head, total, pay_rows, tax_rows, items }
      if (parsed && typeof parsed === "object" && (parsed.head || parsed.items || parsed.pay_rows)) {
        const head = parsed.head || {};
        const total = parsed.total || {};
        const payRows = parsed.pay_rows || [];
        const items = parsed.items || [];

        return `
          <div class="divider"></div>
          <div class="section-title">Receipt</div>

          <div class="section-title">CHECKHEAD</div>
          ${renderKeyValueTable(head)}

          <div class="section-title">CHECKTOTAL</div>
          ${renderKeyValueTable(total)}

          <div class="section-title">CHECKPAY</div>
          ${renderRowsTable(payRows, ["PAYFORMNM","PAYFORMCD","SUM","PROVIDED","REMAINS"])}

          <div class="section-title">CHECKBODY</div>
          ${renderRowsTable(items, ["CODE","NAME","AMOUNT","UNITNM","PRICE","COST","LETTERS"])}
        `;
      }

      // fallback: parse in browser from xmlText
      if (xmlText) {
        const summary = parseXmlToSummary(xmlText);
        if (summary) {
          return `
            <div class="divider"></div>
            <div class="section-title">Receipt</div>

            <div class="section-title">CHECKHEAD</div>
            ${renderKeyValueTable(summary.head)}

            <div class="section-title">CHECKTOTAL</div>
            ${renderKeyValueTable(summary.total)}

            <div class="section-title">CHECKPAY</div>
            ${renderRowsTable(summary.payRows, ["PAYFORMNM","SUM"])}

            <div class="section-title">CHECKBODY</div>
            ${renderRowsTable(summary.bodyRows, ["CODE","NAME","AMOUNT","UNITNM","PRICE","COST","LETTERS"])}
          `;
        }
      }

      return `
        <div class="divider"></div>
        <div class="section-title">Receipt</div>
        <div class="muted">No parsed data available.</div>
      `;
    }

    function showDetails(scan, opts = { scroll: false }) {
      if (!scan) {
        detailsEl.textContent = "Select a scan to view details.";
        return;
      }

      state.selectedScanKey = scan.raw_text;

      const infoEntries = Object.entries(scan.info || {});
      const infoGrid = infoEntries.length
        ? infoEntries.map(([key, value]) => {
            const safeValue = Array.isArray(value) ? value.join(", ") : String(value);
            return `<div class="detail"><strong>${escapeHtml(key)}</strong><div>${escapeHtml(safeValue)}</div></div>`;
          }).join("")
        : "<div class=\"muted\">No structured data.</div>";

      const cached = state.checkCache.get(scan.raw_text);
      const receiptBlock = cached ? renderParsedReceipt(cached.parsed, cached.text) : "";

      detailsEl.innerHTML = `
        <div class="tag">${escapeHtml(scan.type)}</div>
        <div><strong>Raw:</strong> ${escapeHtml(scan.raw_text)}</div>
        <div><strong>Scanned:</strong> ${new Date(scan.created_at).toLocaleString()}</div>
        <div class="details-grid">${infoGrid}</div>
        ${receiptBlock}
      `;

      if (opts && opts.scroll) {
        detailsCardEl.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }

    function hydrateStatusesFromHistory(scansUniq) {
      // trust server status in scan.info.check_status
      for (const s of scansUniq) {
        const key = s.raw_text;
        if (!key) continue;

        const st = pickDbStatus(s);
        if (st.founded) state.findStatus.set(key, "founded");
        if (st.saved) state.saveStatus.set(key, "saved");
      }
    }

    async function fetchHistory() {
      if (!state.userId) {
        historyEl.textContent = "Connect Telegram to view history.";
        return;
      }
      try {
        const response = await fetch(`${apiBase}/api/history?user_id=${state.userId}`);
        if (!response.ok) throw new Error("Failed to load history");

        const scansAll = await response.json();

        // unique by raw_text (keep latest created_at)
        const map = new Map();
        for (const s of scansAll) {
          const key = s.raw_text;
          if (!key) continue;
          const prev = map.get(key);
          if (!prev) {
            map.set(key, s);
          } else {
            const a = new Date(prev.created_at).getTime();
            const b = new Date(s.created_at).getTime();
            if (b > a) map.set(key, s);
          }
        }
        const uniq = Array.from(map.values()).sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
        state.scans = uniq;

        hydrateStatusesFromHistory(uniq);
        renderHistory();
      } catch {
        historyEl.textContent = "Unable to load history.";
      }
    }

    async function submitScan(rawText) {
      if (rawText.length > 4096) return setStatus("QR text too long.");
      if (!state.userId) return setStatus("Missing Telegram user info.");

      try {
        const response = await fetch(`${apiBase}/api/scan`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            raw_text: rawText,
            tg_user_id: state.userId,
            timestamp: new Date().toISOString(),
          }),
        });
        if (!response.ok) throw new Error("Failed to store scan");

        const scan = await response.json();
        upsertUniqueScan(scan);
        renderHistory();
        showDetails(scan, { scroll: true });
        setStatus("Scan stored.");
      } catch {
        setStatus("Failed to store scan.");
      }
    }

    function handleQrText(rawText) {
      const now = Date.now();
      if (continuousToggle.checked && rawText === state.lastText && now - state.lastTextAt < 2000) return;

      state.lastText = rawText;
      state.lastTextAt = now;

      setStatus("QR detected.");
      if (tg && tg.HapticFeedback) tg.HapticFeedback.notificationOccurred("success");

      submitScan(rawText);

      if (tg) tg.sendData(rawText);
      if (!continuousToggle.checked && tg && tg.closeScanQrPopup) tg.closeScanQrPopup();
    }

    async function findCheckForScan(scan) {
      const key = scan.raw_text;
      const url = getValidCheckUrl(key);
      if (!url || !state.userId) return;

      // if already saved -> treat as founded
      if ((state.saveStatus.get(key) || "idle") === "saved") {
        state.findStatus.set(key, "founded");
        return;
      }

      state.findStatus.set(key, "loading");
      renderHistory();

      try {
        await new Promise((r) => setTimeout(r, 5000)); // your 5s delay

        const response = await fetch(`${apiBase}/api/find_check`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tg_user_id: state.userId, check_url: url }),
        });

        if (!response.ok) {
          let msg = "Failed to fetch check";
          try {
            const err = await response.json();
            if (err && err.detail) msg = err.detail;
          } catch {}
          throw new Error(msg);
        }

        const data = await response.json();

        state.checkCache.set(key, {
          text: data.text || "",
          parsed: data.parsed || null,
          check_id: data.check_id || null,
          founded: Boolean(data.founded),
          saved: Boolean(data.saved),
        });

        state.findStatus.set(key, "founded");
        if (data.saved) state.saveStatus.set(key, "saved");
      } catch {
        state.findStatus.set(key, "failed");
      }
    }

    async function saveCheckForScan(scan) {
      const key = scan.raw_text;
      const url = getValidCheckUrl(key);
      if (!url || !state.userId) return;

      if ((state.saveStatus.get(key) || "idle") === "saved") return;

      const cached = state.checkCache.get(key);
      if (!cached || !cached.text) return;

      state.saveStatus.set(key, "loading");
      renderHistory();

      try {
        const response = await fetch(`${apiBase}/api/save_check`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            tg_user_id: state.userId,
            check_url: url,
            check_text: cached.text,
          }),
        });

        if (!response.ok) {
          let msg = "Failed to save check";
          try {
            const err = await response.json();
            if (err && err.detail) msg = err.detail;
          } catch {}
          throw new Error(msg);
        }

        const data = await response.json();

        state.findStatus.set(key, "founded");
        state.saveStatus.set(key, "saved");

        // update cache with backend parsed (important for details)
        state.checkCache.set(key, {
          text: cached.text,
          parsed: data.parsed || cached.parsed || null,
          check_id: data.check_id || cached.check_id || null,
          founded: true,
          saved: true,
        });

        setStatus("Saved.");
      } catch {
        state.saveStatus.set(key, "failed");
        setStatus("Failed to save.");
      }
    }

    function initTelegram() {
      if (!tg) {
        notTelegramEl.style.display = "block";
        scanButton.disabled = true;
        return;
      }

      tg.expand();
      state.userId = tg.initDataUnsafe && tg.initDataUnsafe.user ? tg.initDataUnsafe.user.id : null;

      fetchHistory();

      if (!tg.showScanQrPopup) {
        setStatus("QR scanning is not supported in this Telegram version.");
        scanButton.disabled = true;
        return;
      }

      tg.onEvent("qrTextReceived", (event) => {
        if (event && event.data) handleQrText(event.data);
      });

      scanButton.addEventListener("click", () => {
        setStatus("Scanning...");
        tg.showScanQrPopup({ text: "Point your camera at a QR code." });
      });
    }

    initTelegram();
  </script>
</body>
</html>